//
//  WebSocketError.swift
//  victorious
//
//  Created by Sebastian Nystorm on 15/3/16.
//  Copyright Â© 2016 Victorious. All rights reserved.
//

import Foundation

//
// The differents error cases originating from the WebSocket. Could either be custom ones from our backend or 
/// be the ones baked into the protocol generated by the OS.
//
// - MissingAppId: Nonexisting app id sent.
// - MissingToken: Token did not exist in URL for opening the WebSocket connection.
// - UnsupportedApp: Current app has no support for WebSockets.
// - UnrecognizedToken: Token not recognized.
// - UnsupportedProtocol: Protocol sent is not valid, this does NOT refer to the actual WebSocket protocol but the part we use to transfer data.
// - ConnectionTerminated: Connection closed, could contain a code and an error.
//
public enum WebSocketError: ErrorType, Equatable, CustomStringConvertible {
    case MissingAppId(message: String)
    case MissingToken(message: String)
    case UnsupportedApp(message: String)
    case UnrecognizedToken(message: String)
    case UnsupportedProtocol(message: String)
    case ConnectionTerminated(code: Int?, message: String?)

    public var description: String {
        var description: String

        switch self {
            case .MissingAppId(let message):
                description = message
            case .MissingToken(let message):
                description = message
            case .UnsupportedApp(let message):
                description = message
            case .UnrecognizedToken(let message):
                description = message
            case .UnsupportedProtocol(let message):
                description = message
            case .ConnectionTerminated(let code, let error):
                return "Connection terminated. Code: \(code) Error: \(error)"
        }

        return description
    }

    /// Create a WebSocketError from JSON, the `didDisconnect` flag is used to distinguish between error messages originating 
    /// from a closed connection.
    public init?(json: JSON, didDisconnect: Bool) {
        guard
            let message = json["message"].string,
            let code = json["code"].int
        else {
            return nil
        }

        if didDisconnect {
            self = .ConnectionTerminated(code: code, message: message)
        } else {
            // Error codes are not important to us on a system level since we translate them into our enum.
            switch code {
                case 10:
                    self = .MissingAppId(message: message)
                case 20:
                    self = .MissingToken(message: message)
                case 30:
                    self = .UnsupportedApp(message: message)
                case 40:
                    self = .UnrecognizedToken(message: message)
                case 50:
                    self = .UnsupportedProtocol(message: message)
                default:
                    return nil
            }
        }
    }
}

public func ==(lhs: WebSocketError, rhs: WebSocketError) -> Bool {
    switch (lhs, rhs) {
        case (let .MissingAppId(message1), let .MissingAppId(message2)):
            return (message1 == message2)
        case (let .MissingToken(message1), let .MissingToken(message2)):
            return (message1 == message2)
        case (let .UnsupportedApp(message1), let .UnsupportedApp(message2)):
            return (message1 == message2)
        case (let .UnrecognizedToken(message1), let .UnrecognizedToken(message2)):
            return (message1 == message2)
        case (let .UnsupportedProtocol(message1), let .UnsupportedProtocol(message2)):
            return (message1 == message2)
        case (let .ConnectionTerminated(code1, message1), let .ConnectionTerminated(code2, message2)):
            return (code1 == code2) || (message1 == message2)
        default:
            return false
    }
}
